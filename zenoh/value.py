#
# Copyright (c) 2022 ZettaScale Technology
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors:
#   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
#
import abc
from typing import Union, Tuple, Optional, List, Type, TypeVar
import json
import struct

from .enums import Encoding, SampleKind, Priority, CongestionControl
from .zenoh import _Value, _Encoding, _Sample, _SampleKind, _Reply, _ZenohId, _Timestamp, _Hello, _QoS
from .keyexpr import KeyExpr, IntoKeyExpr

IntoPayload = Union[bytes, str, int, float, bool, list, dict]

def into_payload(obj: IntoPayload) -> bytes:
    if isinstance(obj, bytes):
        return obj
    if isinstance(obj, str):
        return obj.encode()
    if isinstance(obj, int):
        return struct.pack('<q', obj).rstrip(b'\0')
    if isinstance(obj, float):
        return struct.pack('<d', obj).rstrip(b'\0')
    if isinstance(obj, (dict, list)):
        return json.dumps(obj).encode()
    raise NotImplementedError()

T = TypeVar("T", bytes, str, int, float, bool, list, dict)
def from_payload(tp: Type[T], payload: bytes) -> T:
    if tp == bytes:
        return payload
    if tp == str:
        return payload.decode()
    if tp == int:
        if len(payload) > 8:
            raise ValueError("invalid int payload")
        return struct.unpack('<q', payload + b'\0' * (8 - len(payload)))[0]
    if tp == float:
        if len(payload) > 8:
            raise ValueError("invalid float payload")
        return struct.unpack('<d', payload + b'\0' * (8 - len(payload)))[0]
    if tp in (list, dict):
        return json.loads(payload)
    raise NotImplementedError()

class ZenohId(_ZenohId):
    """A Zenoh UUID"""
    @staticmethod
    def _upgrade_(this: _ZenohId) -> 'ZenohId':
        return _ZenohId.__new__(ZenohId, this)
    def __str__(self) -> str:
        return super().__str__()
    def __repr__(self) -> str:
        return str(self)

class Timestamp(_Timestamp):
    """
    A timestamp taken from the Zenoh HLC (Hybrid Logical Clock).

    These timestamps are guaranteed to be unique, as each machine annotates its perceived time with a UUID, which is used as the least significant part of the comparison operation.
    """
    @staticmethod
    def _upgrade_(this: _Timestamp) -> 'Timestamp':
        return _Timestamp.__new__(Timestamp, this)
    @property
    def get_time(self) -> int:
        """
        Returns the time part, as generated by the Zenoh HLC in NTP64 format (See https://datatracker.ietf.org/doc/html/rfc5905#section-6).
        """
        return super().time
    @property
    def seconds_since_unix_epoch(self) -> float:
        """
        Returns the number of seconds since the Unix Epoch.

        Considering the large number of seconds since the Unix Epoch, the precision of the resulting f64 is in the order of microseconds.
        Therefore, it should not be used for comparison. Directly comparing Timestamp objects is preferable.
        """
        return super().seconds_since_unix_epoch

class QoS(_QoS):
    """
    Quality of Service settings.
    """
    def __new__(cls):
        return super().new()
    @property
    def priority(self) -> Priority:
        "Priority"
        return Priority(super().priority)
    @property
    def congestion_control(self) -> CongestionControl:
        "Congestion control"
        return CongestionControl(super().congestion_control)
    @property
    def express(self) -> bool:
        "Express flag: if True, the message is not batched during transmission, in order to reduce latency."
        return super().express
    @staticmethod
    def _upgrade_(inner: _QoS) -> 'QoS':
        if isinstance(inner, QoS):
            return inner
        return _QoS.__new__(QoS, inner)
    
QoS.DEFAULT = QoS()
    

IntoSample = Union[_Sample, Tuple[IntoKeyExpr, IntoValue, SampleKind], Tuple[KeyExpr, IntoValue]]
class Sample(_Sample):
    """
    A KeyExpr-Value pair, annotated with the kind (PUT or DELETE) of publication used to emit it and a timestamp.
    """
    def __new__(cls, key: IntoKeyExpr, payload: IntoPayload, *, encoding: Encoding = None, kind: SampleKind = None, qos:QoS = None, timestamp: Timestamp = None):
        kind = _SampleKind.PUT if kind is None else kind
        qos = QoS.DEFAULT if qos is None else qos
        return Sample._upgrade_(super().new(KeyExpr(key), into_payload(payload), encoding, qos, kind, timestamp))
    @property
    def key_expr(self) -> KeyExpr:
        "The sample's key expression"
        return KeyExpr(super().key_expr)
    @property
    def payload(self) -> bytes:
        "A shortcut to ``self.value.payload``"
        return super().payload
    @property
    def encoding(self) -> Encoding:
        "A shortcut to ``self.value.encoding``"
        return Encoding(super().encoding)
    @property
    def kind(self) -> SampleKind:
        "The sample's kind"
        return SampleKind(super().kind)
    @property
    def timestamp(self) -> Optional[Timestamp]:
        "The sample's  timestamp. May be None."
        ts = super().timestamp
        return None if ts is None else Timestamp._upgrade_(ts)
    @property
    def qos(self) -> QoS:
        "Quality of service settings the sample was sent with"
        return QoS._upgrade_(super().qos)
    @staticmethod
    def _upgrade_(inner: _Sample) -> 'Sample':
        if isinstance(inner, Sample):
            return inner
        return _Sample.__new__(Sample, inner)

class Reply(_Reply):
    """
    A reply to a query (``Session.get``).
    
    A single query can result in multiple replies from multiple queryables.
    """
    def __new__(cls, inner: _Reply):
        return super().__new__(cls, inner)
    @property
    def replier_id(self) -> ZenohId:
        "The reply's sender's id."
        return ZenohId._upgrade_(super().replier_id)
    
    @property
    def is_ok(self) -> bool:
        """
        Checks if the reply is `ok`.

        Returns `True` if the reply is `ok`, `False` otherwise
        """
        return super.is_ok()

    @property
    def ok(self) -> Sample:
        """
        The reply's inner data sample.

        Raises a ``ZError`` if the ``self`` is actually an ``err`` reply.
        """
        return Sample._upgrade_(super().ok)
    @property
    def err(self) -> Value:
        """
        The reply's error value.

        Raises a ``ZError`` if the ``self`` is actually an ``ok`` reply.
        """
        return Value._upgrade_(super().err)

class Hello(_Hello):
    "Represents a single Zenoh node discovered through scouting."
    @property
    def zid(self) -> ZenohId:
        "The node's Zenoh UUID."
        zid = super().zid
        return None if zid is None else ZenohId._upgrade_(zid)
    @property
    def whatami(self) -> str:
        "The node's type, returning either None, 'peer', 'router', or 'client'."
        return super().whatami
    @property
    def locators(self) -> List[str]:
        "The locators through which this node may be adressed."
        return super().locators
    @staticmethod
    def _upgrade_(inner: _Hello) -> 'Sample':
        if isinstance(inner, Hello):
            return inner
        return _Hello.__new__(Hello, inner)
    def __str__(self):
        return super().__str__()